Запуск итогового решения: "go run ./error compensation/main.go /file/with/numbers"

Для сравнений я написал программу, которая просто складывает числа с плавающей точкой
Файл "./basic/main.go"

Из курса ЭВМ известно, что для представления чисел в компьютере используется ограниченное число бит.
Первое, что приходит в голову: чтобы увеличить точность, нужно увеличить кол-во бит, отведенных для мантисы и порядка.
Файл "./bigFloat/main.go"

Однако всегда будут числа, которые не получится точно перевести из 10-ичной в 2-ичную систему счислений. И всегда будут округления при сложении и вычитании.
И можно бесконечно увеличивать кол-во бит числа. (так же растет кол-во времени на мат. операции)
Если ограничиться типом float64, то было бы удобно находить погрешность при сложении пары чисел. Так я и сделал в итоговом решении
Файл "./error compensation/main.go"
Я суммирую все числа и в то же время вычисляю погрешность
В итоге у меня есть простая сумма чисел и суммарная погрешность
Если я вычту это погрешность из суммы чисел, я получу наиболее точную сумму чисел

Вообще этот вопрос расматривался у меня в ВУЗе на курсе ЭВМ и ПУ (Периферийные устройства).
Для воспоминания я просмотрел следующие источники:
1. https://www.youtube.com/watch?v=U0U8Ddx4TgE&ab_channel=AlekOS
2. https://habr.com/ru/articles/266023/

В целом алгоритм взят из второго источника, но я его немного переделал: я суммирую погрешность, и только потом прибавляю к итоговой сумме